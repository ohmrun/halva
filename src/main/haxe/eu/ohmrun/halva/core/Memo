package eu.ohmrun.halva.core;

class MemoCls<T>{
  public final value   : T;
  public  final frozen  : Bool;

  public function new(value,?frozen = false){
    this.value  = value;
    this.frozen = frozen;
  }
  public function copy(?value:T,?frozen:Bool){
    return new MemoCls(
      __.option(value).defv(this.value),
      __.option(frozen).defv(this.frozen)
    );
  }
}
@:using(eu.ohmrun.halva.core.Memo.MemoLift)
@:forward abstract Memo<T>(MemoCls<T>) from MemoCls<T> to MemoCls<T>{
  static public var _(default,never) = MemoLift;
  public inline function new(self:MemoCls<T>) this = self;
  @:noUsing static inline public function lift<T>(self:MemoCls<T>):Memo<T> return new Memo(self);

  public function prj():MemoCls<T> return this;
  private var self(get,never):Memo<T>;
  private function get_self():Memo<T> return lift(this);
  
  @:noUsing static public function make<T>(value:T,frozen:Bool){
    return new Memo(new MemoCls(value,frozen));
  }
  @:from static public function fromT<T>(value:T){
    return pure(value);
  }
  @:noUsing static public function pure<T>(v:T){
    return make(v,false);
  }
  public function freeze(){
    return make(this.value,true);
  }
}
class MemoLift{
  static public inline function lift<T>(self:MemoCls<T>):Memo<T>{
    return Memo.lift(self);
  }
  static public inline function zip_asto<Ti,Tii>(lhs:Memo<Ti>,rhs:Memo<Tii>):Option<Couple<Ti,Tii>>{
    return switch([lhs.prj(),rhs.prj()]){
      case [{ frozen : true}, {frozen : false }]                            : None;
      case [{ frozen : false, value : vI}, {frozen : true, value : vII }]   : Some(__.couple(vI,vII));
      case [{ frozen : false, value : vI}, {frozen : false, value : vII}]   : Some(__.couple(vI,vII));
      case [{ frozen : true, value : vI}, {frozen : true, value : vII}]     : Some(__.couple(vI,vII));
      default : None;
    }
  }
}